This is an implementation of the liteRISC CPU with a complete subsystem including a
serial UART and GPIO. This subsystem is complete implementation that can be
synthesized with Vivado and run in an FPGA.

The CPU design is done in MyHDL which is a Python based language that generates Verilog.

To create the Verilog source you need a Python 3 installation and then the
complete Verilog is generated by:

./gen.sh gensoc.py

The submodules can be generated separately by:
./gen.sh gencsys.py
./gen.sh gencpu.py

The design hierarchy is:

  blinky2
    clkwiz                - clock generator created in Vivado, no source
    baud_rate_generator   - UART design by David Marion in Verilog
    uart_transmitter        -"-
    uart_receiver           -"-
    uart_tx_ctrl            -"-
    soc                   - soc.py
      axi_periphery       - axi_slaves.py
      cpu_sys             - cpu_sys.py
        cpu               - cpu.py
        imem (rom)
        pmem (dp_mem)     - dp_mem.py - infered memory in Vivado
        dmem (dp_mem)
        axi_master

In cpu_sys the CPU is connected to an instruction memory, a data memory, a boot
rom and an AXI master. The only interface from cpu_sys are clock/reset and an AXI bus.

In soc there is a AXI slave with register interface to GPIO and the UART.

In the top level the clock generator and the UART submodules are connected to the soc.

----------------- Testbenches ------------------------------------

------ CPU regression testbench
The CPU has a MyHDL testbench that tests all instructions with coverage.
When running the testbench it will always output a waveform in trace.vcd.
Recommend to use gtkwave for viewing the waveform.

To run single test, all tests or generate Verilog:
./gen.sh tb.py sim <test-case-number>
./gen.sh tb.py sim all
./gen.sh tb.py

Regression check:
./gen.sh tb.py sim all | egrep 'tests pass:|MISS'

------ SOC bringup testbench
There is a MyHDL bringup testbench for the soc instance. This is not self checking
testbench. It's not meant for regression. It contains a mockup of the UART so
that the connection to the AXI slaves can be tested. The CPU program needs to be
setup in cpu_sys.py for what connection you want to test.

Run with:
./gen.sh tbsoc.py

------ SOC Verilog testbench
To test the UART connection there is a Verilog testbench that instantiates
the UART modules and connects them to the soc module. There is nothing Again this is not self checking
and the CPU program needs to be setup. UART transmit line is connected to the receive line
so a simple loopback test can be done.

The simulation uses Icarus verilog simulator (must be recent version so that it supports
some System Verilog constructs).

./run_icarus.sh

------ Vivado xsim
The complete design (blinky2) can be simulated in xsim to see that clock and reset
works and that the baud rate is correct. Simple connectivity can be viewed in the waveform.
But there is no testbench for this so just build the simulator in vivado and force the
reset and clocks in the waveform.


------ Testbench for the 2s complement 8/16/32-bit subtraction module
The CPU need 8/16 and 32 bit subtraction and additions with flags for all
sizes. This is implemented in a module that has configurable width and where
the wider operations are built from the results from narrower operations.

To verify the algoritm and connections the testbench runs all combinations of operands
and compares the result with expected. The operand size is set to 2 bits to avoid
long run time but the testbench has been run for larger operand size.

./gen.sh test_sub.py verify
./gen.sh test_sub.py gen
